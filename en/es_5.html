<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>JavaScript Language Basics – Lesson 5</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/codemirror.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/theme/darcula.css" />
  <link rel="stylesheet" href="codeblocks.css" />
</head>
<body>
  <header>
    <h1>Lesson 5 – Error Handling, Modules, Prototype</h1>
    <p>
      In this lesson, we cover three more advanced topics:
    </p>
    <ol>
      <li>how to handle errors and unexpected situations,
      <li>how to organize code into modules,
      <li>what is the foundation of JavaScript's object system: the prototype chain.
    </ol>
    <p>
      The goal is not to understand everything down to the last detail, but to clarify the underlying model:
      when to throw an error, when to catch it, how to split code into files,
      and why inheritance works the way it does.
    </p>
  </header>

  <main>
    <section>
      <h2>1. Error Handling</h2>

      <article>
        <h3>1.1. What is a runtime error</h3>
        <p>
          <strong>Runtime error</strong> occurs when, during program execution,
          we encounter a situation that JavaScript cannot "guess" or handle automatically.
          At that point, execution stops unless we catch the error with error handling.
        </p>
        <p>
          For example: referencing a non-existent variable, calling a method on the wrong type, or
          a function "not knowing" how to handle the input.
        </p>

        <p>This kind of error can also be generated by us. The <code>throw</code> keyword is meant for exactly this: creating an error.</p>
        <textarea data-lang="js">
console.log("Program is running 1")
throw new Error("Big ugly error.")
console.log("Program is running 2")
        </textarea>
        <p>
	As you see, the program stops at the second line, so the code after that is not executed.
	</p>
        <p>
	Why would we want the program to stop? Because we can handle the error.
	It's often much better to know that an error occurred rather than silently ignoring strange behavior.
	For example, as mentioned, dividing by zero in JavaScript is not an error.
	If this bothers our mathematical sense, we can create a "safe" division function
	that throws an error if such a situation occurs.
	</p>
        <textarea data-lang="js">
function safeDivide(a, b) {
  if (typeof a !== "number" || typeof b !== "number")
    throw new TypeError("safeDivide accepts only numbers")

  if (b === 0)
    throw new RangeError("Division by zero is not allowed")

  return a / b
}

try {
  console.log(safeDivide(10, 2))
  console.log(safeDivide(10, 0))
  console.log("This will not be seen if we don't handle the error")
} catch (err) {
  console.log("An error occurred:", err.name, "-", err.message)
}
        </textarea>

        <p>
          Why is this pattern good? Because <strong>the cause of the error is indicated where it occurs</strong>
          (<code>throw</code>), but <strong>it is handled where it makes sense</strong> (in the user logic).
          This keeps your functions clean: they either return a good result or clearly indicate they cannot.
        </p>
      </article>

      <article>
        <h3>1.2. try / catch / finally</h3>
        <p>
          In the <code>try</code> block, you run code that might throw an error.
          In the <code>catch</code> block, you catch and handle the error.
          The <code>finally</code> block <em>always runs</em>, whether an error occurred or not.
        </p>
        <p>
          The typical role of <code>finally</code>: "cleanup" (closing resources, restoring state,
          logging, releasing UI buttons).
        </p>

        <textarea data-lang="js">
function parseJsonOrNull(text) {
  try {
    // the following statement either works or throws an error,
    // if the text is not valid JSON, an error occurs.
    return JSON.parse(text)
  } catch (err) {
    return null
  } finally {
    console.log("parseJsonOrNull executed")
  }
}

json_data = '{"ok": true, "n": 42}'
console.log(parseJsonOrNull(json_data))
        </textarea>
        <p>Try it! Change the content of <code>json_data</code> to some nonsensical gibberish and run it.</p>

        <p>
          Why do we expect an error here? Why don't we give normal data? Because in real life, input often
          comes from uncontrolled sources (user, file, network).
	  If we don't control it, we can't guarantee it's good and correct.
	  Error handling is part of program stability.
        </p>
      </article>

      <article>
        <h3>1.3. Asynchronous preview: try/catch won't catch everything</h3>
        <p>
          Important: <code>try/catch</code> will catch <strong>synchronous</strong> code.
          If an error occurs later (for example, in a timer), it is not in the same execution "moment".
	  It won't be "caught".
          (This will be explained in detail in Lesson 6.) 
        </p>

        <textarea data-lang="js">
try {
  setTimeout(() => {
    // This is an error because such a function does not exist:
    notExistingFunction()
  }, 0)

  console.log("The try block has already ended")
} catch (err) {
  console.log("You won't see this (if no error occurred)")
}
        </textarea>

        <p>
          Why is this important? Because if you have asynchronous code, your error handling strategy
          (for example, Promise/async/await) will be different.
        </p>
      </article>
    </section>

    <section>
      <h2>2. Strict mode</h2>

      <article>
        <h3>2.1. What does "use strict" do</h3>
        <p>
          The <code>"use strict"</code> is a switch that enforces stricter rules on JavaScript.
          In modern environments (like ES modules), strict mode is enabled by default, but in older or
          looser runtime environments, you might still encounter it.
        </p>
        <p>
          The purpose of strict mode: <strong>to signal errors earlier and more loudly</strong>,
          especially for problematic patterns that would otherwise pass silently and cause hidden bugs later.
        </p>
        <textarea data-lang="js">
function sloppyExample() {
  // "use strict"
  x = 10
  return x
}

function strictExample() {
  "use strict"
  // here the next line throws an error because x is not declared
  x = 10
  return x
}

console.log("sloppyExample:", sloppyExample())

try {
  console.log("strictExample:", strictExample())
} catch (err) {
  console.log("Strict mode error:", err.name, "-", err.message)
}
        </textarea>
        <p>
          Why is this good? Because the "accidental global variable" (like the <code>x</code> above) is a common source of bugs:
          easy to overwrite, hard to debug. Strict mode immediately stops this.
        </p>
      </article>
    </section>

    <section>
      <h2>3. Modules</h2>

      <article>
        <h3>3.1. Why are modules needed</h3>
        <p>
          Modules are necessary because if everything is written in one file, the code becomes unmanageable over time:
          hard to navigate, hard to reuse parts, and easy to create name conflicts,
	  plus, if multiple developers work on it, everyone would be editing the same file.
        </p>
        <p>
          The goals of modules:
        </p>
        <ul>
          <li>separating code by <strong>responsibilities</strong></li>
          <li>explicit <strong>public API</strong> (export) declaration</li>
          <li>explicit <strong>dependency management</strong> (import)</li>
        </ul>
      </article>

      <article>
        <h3>3.2. export and import (ES module syntax)</h3>
        <p>
          In the world of ES (EcmaScript) modules, a module <strong>exports</strong> things (functions, constants, objects),
          and another module <strong>imports</strong> them. Essentially, this is a contract
          between files: what you export, and what you use.
        </p>

        <p>
	This is good for both the file that provides the code (exports) and the one that uses it (imports). The exporting code can be sure that
	anything not exported cannot be overwritten or broken by the importer, because it cannot see it. The importing code gets a well-defined
	clear "interface" to achieve its goals, without dealing with implementation details.
	</p>

        <p>The importing code doesn't care how the data (like a person's name) gets stored or how the interactive graph is generated; it just calls the function with parameters.</p>
        <p>For example, passing a name parameter to storeUser, or providing data in a data parameter when calling CreateFancyGraph.</p>

        <p>
          The following examples illustrate two typical export formats:
          <strong>named export</strong> and <strong>default export</strong>.
          These cannot be run here because code blocks do not support import/export, so they are just for illustration.
        </p>

        <p>This would be one file (the exporter). The filename is math.js</p>
        <textarea data-lang="js" data-readonly>
/* math.js */
export function add(a, b) {
  return a + b
}

export const PI = 3.141592653589793
        </textarea>

        <p>This would be another file that imports (say index.js):</p>
        <textarea data-lang="js" data-readonly>
/* index.js */
import { add, PI } from "./math.js"

console.log(add(2, 3))
console.log(PI)
        </textarea>
      </article>

      <article>
        <h3>3.3. Importing from an external URL (external library)</h3>
        <p>
          In modern browsers, you can import directly from a URL.
        </p>
        <p>
          The example below imports a function <code>chunk</code> from the <code>lodash-es</code> package via the <code>jsDelivr</code> ESM endpoint. Unfortunately, you cannot run this here.
        </p>

        <textarea data-lang="js" data-readonly>
import chunk from "https://cdn.jsdelivr.net/npm/lodash-es@4.17.21/chunk.js"

console.log(chunk([1, 2, 3, 4, 5], 2))
        </textarea>

        <p>
          It's worth seeing at least once. The module system is the same; the only difference is that the dependency is a URL, not a local file.
          The "what I use" remains explicit.
        </p>
      </article>

      <article>
        <h3>3.4. Module without feeling of impact: a runnable "mini-module" pattern</h3>
        <p>
          If there is no module system (or your runtime environment doesn't support modules), it's still worthwhile to
          "encapsulate" your code to avoid polluting the global namespace with variables.
	  A classic pattern for this is the IIFE (Immediately Invoked Function Expression).
	  You might encounter this in older code (pre-module era):
        </p>

        <textarea data-lang="js">
const MathBox = (() => {
  const PI = 3.141592653589793

  function add(a, b) {
    return a + b
  }

  function circleArea(r) {
    return PI * r * r
  }

  return { add, circleArea }
})()

console.log(MathBox.add(2, 3))
console.log(MathBox.circleArea(10))
        </textarea>
        <p> This strange form is a function definition that is immediately invoked (hence the empty parentheses at the end). 
	<code>(() => { ...program... })()</code>
	</p>
	<p>This immediately executes and returns an object (in this case, an object with properties <code>add</code> and <code>circleArea</code>), so <code>MathBox</code> ends up being such an object. Clever, isn't it?</p>
        <p>
          It's a bit complicated, but why is it better than just defining functions directly? Because of scope rules (everything only visible inside the block where it was created),
	  internal variables (<code>PI</code>) do not leak out, and the public API is visible only as a single object (<code>MathBox</code>).
          Logically, a module is exactly this: internal part + exported interface.
        </p>
	<p>
	Imagine one developer used <code>PI</code> somewhere in the code (e.g., calculating an area). But we want to use another package that also uses the name <code>PI</code>, but in a different context (say, as a Protocol Identifier with value "89541-2"). It’s conceivable that overwriting the old <code>PI</code> would break the calculations. So sometimes, it’s very useful that they are not visible to each other.
	</p>
	<p>In short, sometimes it’s very useful if they are not visible to each other.</p>
      </article>
    </section>

    <section>
      <h2>4. Special object syntax</h2>

      <article>
        <h3>4.1. Short property</h3>
        <p>
          If the property name and the variable name are the same, the <strong>short property</strong> syntax
          shortens the code: <code>{ x: x }</code> becomes just <code>{ x }</code>.
        </p>

        <textarea data-lang="js">
const x = 10
const y = 20

const pointLong = { x: x, y: y }
const pointShort = { x, y }

console.log(pointLong)
console.log(pointShort)
        </textarea>
        <p>
          Because it reduces noise, and the intent of the code is clearer: "take this variable and assign it as a property with the same name".
	  This form is often used in exports. They do not give it another name.
        </p>
      </article>

      <article>
        <h3>4.2. Computed property</h3>
        <p>
          If the property name is not fixed text but computed at runtime,
          then <strong>computed property</strong> is needed: <code>{ [expr]: value }</code>.
        </p>

        <textarea data-lang="js">
const prefix = "user"
const id = 42

const obj = {
  [prefix + "_" + id]: { name: "Ada", role: "admin" }
}

console.log(obj)
console.log(obj.user_42)
        </textarea>
        <p>
          Why is this good? Because it allows you to build map-like objects
          with dynamic keys, without having to add properties in separate lines later.
        </p>
      </article>

      <article>
        <h3>4.3. Destructuring</h3>
        <p>
          <strong>Destructuring</strong> (breaking apart) is a convenient way to extract multiple values from objects or arrays into variables at once.
          It makes the code more readable than accessing each value on a separate line.
        </p>

        <textarea data-lang="js">
const user = { name: "Mira", age: 29, city: "Budapest" }

const { name, age } = user
console.log(name, age)

const numbers = [10, 20, 30]
const [first, second] = numbers
console.log(first, second)
        </textarea>
        <p>
          Why is this good? Because it immediately shows which fields you need, without repeating the source object name.
        </p>
      </article>
    </section>

    <section>
      <h2>5. Prototype</h2>

      <article>
        <h3>5.1. Prototype chain</h3>
        <p>
          JavaScript was not designed following the classic OOP (Object-Oriented Programming) philosophy,
	  but its capabilities of "inheritance" are imagined through the <strong>prototype chain</strong>:
	  if a property is not found on the object, JS looks at its prototype (which is also an object),
	  to see if it has such a property, then its prototype, and so on.
        </p>
        <p>
          This chain continues until it reaches <code>null</code>. At the top of the chain is typically <code>Object.prototype</code>, which provides many basic methods (like <code>toString</code>).
        </p>
	<p>The following code checks whether the object <code>t</code> has a property called <code>age</code>.</p>
        <textarea data-lang="js">
const t = {age:3}
t.hasOwnProperty('age')
	</textarea>
	<p>But wait! How can we call a method like <code>hasOwnProperty</code> when it is not directly on <code>t</code>?</p>
	<p>Because it is on the prototype object <code>Object</code>. When we referenced it,
	it saw that it was not on this level, so it looked at the prototype, found it there, and used it.</p>
        <textarea data-lang="js">
const t = {age:3}
console.log('not here:', t.hasOwnProperty('hasOwnProperty'))
console.log('from prototype:', t.__proto__.hasOwnProperty('hasOwnProperty'))
	</textarea>
	<p> This is good because it means we don't have to recreate methods for every object. If a proper prototype is set, we "inherit" a lot of functionality for free!</p>
      </article>

      <article>
        <h3>5.2. Own property vs inherited property</h3>
        <p>
          Important distinction: an object can have <strong>own properties</strong> (directly on it),
	  and it can also have properties that exist only because its prototype has them.
	  This affects iteration and debugging.
	  Iteration only examines own properties.
        </p>

        <textarea data-lang="js">
const base = {
  kind: "base",
  describe() {
    return "kind=" + this.kind
  }
}

// obj's prototype will be base:
const obj = Object.create(base)
obj.kind = "child"

console.log("obj.kind:", obj.kind)
console.log("obj.describe():", obj.describe())

console.log("own keys:", Object.keys(obj))
console.log("hasOwn kind:", Object.prototype.hasOwnProperty.call(obj, "kind"))
console.log("hasOwn describe:", Object.prototype.hasOwnProperty.call(obj, "describe"))
        </textarea>
        <p>
	  It's not super simple, but worth thinking about, because many seemingly magical phenomena originate from here.
        </p>
      </article>

      <article>
        <h3>5.3. Object prototype hierarchy</h3>
        <p>
          JavaScript's built-in types also use the prototype chain. For example, an array (created by us) inherits Array methods,
          and through that (ultimately) Object methods as well.
        </p>
        <p>
	This is why you can write <code>arr.push()</code> even though you never explicitly defined <code>push</code>.
        </p>

        <textarea data-lang="js">
const arr = [1, 2, 3]

console.log("arr.push exists:", typeof arr.push)
console.log("arr.toString exists:", typeof arr.toString)

// p1 is the prototype of arr
const p1 = Object.getPrototypeOf(arr)
// p2 is the prototype of p1
const p2 = Object.getPrototypeOf(p1)

console.log("Array.prototype?", p1 === Array.prototype)
console.log("Object.prototype?", p2 === Object.prototype)
        </textarea>
        <p>
           When we say "the object inherits", it specifically means that the search traverses this chain.
        </p>
      </article>
    </section>

    <section>
      <h2>6. Summary</h2>
      <ul>
        <li>
          <strong>Error handling</strong>: <code>throw</code>: signaling an error, <code>try/catch/finally</code>: handling errors.
          Goal: errors should not stop the program but be managed in a controlled way.
        </li>
        <li>
          <strong>Strict mode</strong>: stricter rules, clearer error signals
          (especially against accidental global variables).
        </li>
        <li>
          <strong>Modules</strong>: explicit export/import, clean dependency management, maintainable code structure.
        </li>
        <li>
          <strong>Special object syntax</strong>: short property, computed property, destructuring
          – all help improve code readability and express intent.
        </li>
        <li>
          <strong>Prototype</strong>: JavaScript's inheritance model.
        </li>
      </ul>
    </section>
  </main>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/codemirror.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/mode/javascript/javascript.min.js"></script>
<script src="codeblocks.js"></script>
</html>
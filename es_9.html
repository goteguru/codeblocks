<!doctype html>
<html lang="hu">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>JavaScript nyelvi alapok - 9. lecke</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/codemirror.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/theme/darcula.css">
  <link rel="stylesheet" href="codeblocks.css">
</head>
<body>
  <header>
    <h1>9. lecke - Lokálisan futó JavaScript: Node.js</h1>
    <p>
      Eddig a JavaScriptet főleg böngészőben, "weboldali segédprogramként" láttuk. Ebben a leckében viszont átkapcsolunk
      egy másik nézőpontra: a JavaScript lehet <strong>lokálisan futó program</strong> is, ami fájlokat olvas/ír,
      parancssorból paraméterezhető, vagy akár más programokat vezérel.
    </p>
    <p>
      Ezeket a lehetőségeket a Node.js, egy böngésző nélküli JavaScript "interpreter" (JIT compiler), amely a chrome v8 motorjára épít. 
      Bár a node.js eredeti célja az volt, hogy a szerver oldali funkciókat is JavaScript nyelven lehessen megírni, 
      bármi másra is használhatjuk. Ebben a leckében a fókusz nem is a szerveríráson lesz, hanem a <strong>mérnöki feladatok automatizálásán</strong> ,
      azaz hogyan lehet fájlokat előfeldolgozi, menteni, tömegesen átnevezni, jelentést létrehozni, illetve 
      hogyan használhatjuk a JavaScriptet "ragasztónyelvként" integrációs feladatokban.
    </p>
  </header>

  <main>
    <section>
      <h2>1. Hol fut a Node.js, és miben más, mint a böngésző?</h2>
      <p>
        A <strong>Node.js</strong> egy JavaScript futtatókörnyezet (runtime), amely nem a böngészőben, hanem
        az operációs rendszereden fut. A legfontosabb különbség, hogy ebben az esetben közvetlenül indítasz el
  egy JavaScript <strong>processzt</strong> valahogy így: <code>node valami.mjs</code>.
      </p>

      <p>
        Amitől ez mérnöki szemmel érdekes lehet: Node-ban nem "felhasználói eseményekre" reagálsz, hanem inkább
        <strong>adatokkal és fájlokkal</strong> kapcsolatos "technikai eseményekre", illetve <strong>folyamatokra</strong>.
      </p>

      <ul>
        <li>
          <strong>Nem lesz</strong>: DOM, <code>window</code>, <code>document</code>, böngésző-specifikus API-k.
        </li>
        <li>
          <strong>Cserébe viszont van</strong>: fájlrendszer, process információk, külső programindítás, hálózat alacsonyabb szinten.
        </li>
      </ul>

      <p>
        A böngészőben a globális objektum neve jellemzően <code>window</code>. Node-ban ennek megfelelője a <code>global</code>.
        Ha viszont nem szeretnél kétféle kódot írni, használhatod a <code>globalThis</code> objektumot:
        ezt pont azért vezették be, hogy mindkét környezetben ugyanazzal a névvel elérhető legyen a globális névtér.
      </p>

      <textarea data-lang="js">
// Böngészőben: window létezik, Node-ban nem
// Node-ban: global létezik, böngészőben nem

// Mindkettőben működik:
console.log(typeof globalThis) // "object"

if ("window" in globalThis) // böngészőben true, Node-ban false
  console.log("Böngészőben vagy")
else if ("global" in globalThis) // Node-ban true
  console.log("Node-ban vagy")
else 
  console.log("Fogalmam nincs hol vagy... :)")
      </textarea>
    </section>

    <section>
      <h2>2. A Node program szerkezete</h2>
      <p>
        Gondolhatsz úgy a node-ra, mint egy kis "céleszközre": elindítod (átadva neki az elvégzendő utasításokat, a programot),
  elvégzi a feladatát, majd kilép. Egy ilyen eszköz (vagy eszközökk!) egyszerűen beépíthetők nagyobb automatizálási láncokba (úgynevezett pipeline-okba).
  Például: a tervezőprogram egy specifikus könyvtárba ment, egy másik segédprogram az adatokon lefuttat egy statikai ellenőrzést, ha az sikeres,
  a automatikusan készül egy előnézet, ami egy sablon kitöltése után tömörítve kiküldésre kerül emailben bizonyos címzetteknek stb.
        </p>

      <p>
        A Node nem szószátyár. Néhány programnyelvben jó pár sornyi kódra van szükség, hogy bármit is csináljon.
  Itt ez nem így van. A legkisebb értelmes Node program akár egy soros is lehet:
      </p>

      <textarea data-lang="js" data-readonly>
// fájl: hello.mjs
console.log("Szia! Ez Node.js-ben ez egy kész program!")
      </textarea>
      <p>
      Ha ezt kimásolod egy fájlba, (mondjuk hello.mjs) átadod a node parancsnak (node hello.mjs),
      akkor már csinálja is. 
      </p>
      
      <p>
      Mint látod, a böngészőhöz képest nem sok változott: ugyanúgy tudunk a console.log-ra írni, csak most az eredmény
      nem a böngészőben, hanem a terminál ablakában jelenik meg.
      </p>

      <p>
      A programot (különösen ha nagyobb) nem muszáj egyetlen fájlban elhelyezni. A programod betölthet 
      további modulokat, olyanokat amiket te magad készítesz, olyanokat amelyeket mások írtak, 
      vagy olyanokat amelyek magába az alaprendszerbe vannak építve.
      </p>

      <p class="info">
        Fontos apróság: a Node-ban a fájlok és útvonalak kezelése érdekes témakör (lásd később:<code>path</code>).
  A böngészőben nem volt ilyen problémánk, mert egy "platformon" (a böngészőn) dolgoztunk, itt viszont
  oda kell figyelnünk a soremelés és útvonalelválasztó karakterekre. A "gyorsan összefűzöm stringként"
  megoldás rövid távon a saját gépeden jól működik, de hosszabb távon platformfüggő hibákat eredményezhet. (Sajnos az operációs
  rendszerek nem egyforma sorvég jeleket használnak, sőt néha még a kódolás sem ugyanaz).
      </p>
    </section>

    <section>
      <h2>3. Modulrendszer Node-ban: ES module</h2>
      <p>
        A modern, jövőbiztos Node kód alapja az <strong>ES module</strong> (ESM): ugyanaz az <code>import</code>/<code>export</code>,
        amit már böngészőben is használtunk. Node-ban ezt két módon tudod használni:
      </p>
      <ul>
        <li><code>.mjs</code> kiterjesztést adsz minden fájlodnak</li>
        <li>vagy a projekt <code>package.json</code> fájljában beállítod: <code>"type": "module"</code></li>
      </ul>
      <p>
      Ez a package.json fontos fájl! A node ebben tartja a configurációját. Később még lesz róla szó.
      </p>

      <p>
        Az alábbi példa két fájlból áll. A kódot itt nem tudjuk futtatni böngészőből, de a struktúra és a szintaxis a lényeg.
	Az első fájl a modul:
      </p>

      <textarea data-lang="js" data-readonly>
// fájl: math.mjs
export function areaOfCircle(r) {
  return Math.PI * r * r
}

export function clamp(x, min, max) {
  return Math.max(min, Math.min(max, x))
}
      </textarea>

      <p>
Ez a második fájl pedig a modult felhasználó program (tradícionálisan main.mjs):
      </p>
      <textarea data-lang="js" data-readonly>
// fájl: main.mjs
import { areaOfCircle, clamp } from "./math.mjs"

let r = 3
let area = areaOfCircle(r)

console.log("Terület:", area)
console.log("Clamp példa:", clamp(120, 0, 100))
      </textarea>
      <p>
      Akárcsak a böngészőben, egyszerűen importáltuk a nekünk szükséges elemeket a másik fájlból. 
      Ugyanúgy mint eddig, csak olyan dolgot importálhatunk, amit a modul <code>export</code> kulcsszóval megjelölt.
      </p>

      <article>
        <h3>3.1. CommonJS modulrendszer</h3>
        <p>
          Régi Node projektekben találkozhatsz egy másféle jelöléssel is: ez a CommonJS.
    Ez a <code>require</code>, <code>module.exports</code> kulcsszavakat használja.
          Új kódot ma már általában nem ebben írunk, viszont <strong>kódolvasáshoz</strong> fontos, hogy felismerd.
        </p>

        <textarea data-lang="js" data-readonly>
// legacy minta (CommonJS) - régi projektekben találkozhatsz vele:
const fs = require("fs")

module.exports = function readText(filePath) {
  return fs.readFileSync(filePath, "utf8")
}
        </textarea>
      </article>
    </section>

    <section>
      <h2>4. Node szerszámosládája: a core modulok</h2>
      <p>
        Node és a böngésző között az egyik legszembetűnőbb különbség, hogy rengeteg alapfunkciót készen megkapsz a
        <strong>beépített (core) modulok által</strong>. A core modulokhoz nem kell külső csomag, elég csak importálni őket.
      </p>
      <p>
      Persze, ha ez nem elég, olyan sok letölthető node modulból választhatsz, hogy győzd végigolvasni!
      </p>

      <article>
        <h3>4.1. Fájlrendszer: <code>fs</code></h3>
  <p>A Node alapvetően async logikát követ. Akkor is ha fizikailag nem használ több processzormagot,
  logikailag úgy képzeljük, hogy a hosszabb időt igénybe vevő folyamatok (például egy fájl olvasása)
  aszinkron módon történik (tehát közben csinálhatunk mást). </p>
  <p>
  Mi már tudjuk, hogy az ilyen aszinkron működést kétféle megközelítéssel is kezelhetjük: vagy átadunk
  egy callback függvényt (amit meg kell hívni, amikor elkészült az adat) vagy használjuk
  a modernebb Promise alapú logikát. A Node alatt általában választhatunk, melyiket szeretnénk.
  </p>
        <p>
          A <code>fs</code> modul a mindennapi automatizálás egyik alappillére. Tipikus feladat például egy JSON export
          beolvasása, módosítása, majd visszaírása.
        </p>

        <textarea data-lang="js" data-readonly>
// fájl: transform-json.mjs
import { readFile, writeFile } from "node:fs/promises"

let inputPath = "input.json"
let outputPath = "output.json"

let text = await readFile(inputPath, "utf8")
let data = JSON.parse(text)

// Példa: minden elem kap egy timestamp-et
let enriched = data.map(x => ({ ...x, processedAt: new Date().toISOString() }))

let outText = JSON.stringify(enriched, null, 2)
await writeFile(outputPath, outText, "utf8")

console.log("Kész:", outputPath)
        </textarea>

        <p class="info">
          Itt a <code>node:fs/promises</code> import azt jelzi, hogy a Promise-alapú API-t használjuk.
          Ez tisztább, átláthatóbb kódot eredményez mint a callback stílus.
        </p>
      </article>

      <article>
        <h3>4.2. Útvonalkezelés: <code>path</code></h3>
        <p>
          Útvonalakat (mappák/fájlok) stringként összerakni csábító, de platformfüggő problémákat okozhat. A <code>path</code> modul
          pont azt segít elkerülni, hogy Linux/Mac/Windows között ugrálva lehetőleg ne romoljon el a programod.
        </p>

        <textarea data-lang="js" data-readonly>
// fájl: paths.mjs
import path from "node:path"

let folder = "exports"
let file = "report.json"

// platformfüggetlen
let fullPath = path.join(folder, file)

console.log(fullPath)
        </textarea>
        <p>
  Így akkor majd ha windows-on fut, backslash-t használ (mert a windows valamiért azt szereti)
  ha meg linux/Mac rendszeren akkor per-jelet.
        </p>
      </article>

      <article>
        <h3>4.3. Process információk: <code>process</code></h3>
        <p>
          A <code>process</code> objektum a futó program "környezete": argumentumok, munkakönyvtár, környezeti változók.
          CLI eszközöknél ez a "vezérlőpult" amivel a programodat konfigurálni, paraméterezni tudod.
        </p>

        <textarea data-lang="js" data-readonly>
// fájl: args.mjs
console.log("Argumentumok:", process.argv)
console.log("Munkakönyvtár:", process.cwd())

// Példa: környezeti változó
let mode = process.env.MODE || "dev"
console.log("MODE:", mode)
        </textarea>
        <p>
  Mentsd el ezt a mini programot egy fájlba és próbáld meg meghívni így: <code>node args.mjs alfa beta gamma 100</code>.
  (Az alfa beta gamma 100 lennének most a paraméterek)
        </p>
        <p>
  Figyeld meg, hogy az argumentumok közt szerepel maga a node, a program amit futtatsz, majd minden további szó 
  amit átadtál.
        </p>
      </article>
    </section>

    <section>
      <h2>5. CLI szemlélet: paraméterezhető scriptek</h2>
      <p>
        A Node nagyon hasznos tud lenni, ha a scriptjeid parancssorból paraméterezhetők. Így egyetlen kódot többféle inputra,
        többféle üzemmódban is le tudsz futtatni (sőt, akár más eszközökből például fájlkezelőből, asztali programból is meghívható).
      </p>

      <p>
        Valahogy így kéne használni (az első "hasznos" argumentum a script neve után jön):
      </p>

      <textarea data-lang="js" data-readonly>
// fájl: cli-min.mjs
// levágjuk a node és a script nevét
let args = process.argv.slice(2)

let inputPath = args[0] || "input.json"
let outputPath = args[1] || "output.json"

console.log("Bemenet:", inputPath)
console.log("Kimenet:", outputPath)
      </textarea>

      <p>
        Általában érdemes bevezetni kapcsolókat is. Például bevezethetnénk egy
  <code>--dry-run</code> módot, amit ha megadunk, akkor a program ténylegesen nem ír a fájlba, csak megmondja, mit csinálna.
      </p>

      <textarea data-lang="js" data-readonly>
// fájl: cli-flags.mjs
let args = process.argv.slice(2)
let dryRun = args.includes("--dry-run")

if (dryRun) {
  console.log("Dry-run: nem írok fájlt, csak szimulálok")
} else {
  console.log("Éles mód: végrehajtom a műveletet")
}
      </textarea>
    </section>

    <section>
      <h2>6. Külső programok indítása: <code>child_process</code></h2>
      <p>
        Mérnöki automatizálásnál sokszor nem az cél, hogy Node segítségével oldj meg mindent, hiszen vannak céleszközeink.
  Van statikai számító program, van CAD vagy elemző program. A kérdés inkább az,
        hogy <strong>tudom-e irányítani</strong> a meglévő eszközeimet: konvertereket, parancssori toolokat, build lépéseket,
        vagy akár CAD/GIS környezethez tartozó segédprogramokat.
      </p>

      <p>
        Az alábbi példa elindít egy parancsot, majd megnézi a visszatérési kódot. A parancs itt most a Node saját 
  programja (<code>process.execPath</code>) lesz, így mindegy milyen operációs rendszeren futtatod, 
  és mi van telepítve nálad, node nyilván fel van telepítve ha el tudtad indítani :
      </p>

      <textarea data-lang="js" data-readonly>
// fájl: run-command.mjs
import { spawn } from "node:child_process"

let child = spawn(process.execPath, ["-v"], { stdio: "pipe" })

let stdout = ""
let stderr = ""

child.stdout.on("data", chunk => {
  stdout += chunk.toString()
})

child.stderr.on("data", chunk => {
  stderr += chunk.toString()
})

child.on("close", code => {
  console.log("Kilépési kód:", code)

  if (code === 0) {
    console.log("Kimenet:", stdout.trim())
  } else {
    console.log("Hiba kimenet:", stderr.trim())
  }
})
      </textarea>
      <p >
      Ez egyben jó példa a callback stílusú eseményvezérlésre. (Sajnos ennek a child_process modulnak
      nincs Promise alapú változata). Láthatod, hogy minden "technikai eseményhez" megadtunk
      egy kezelő-függvényt: ha adat jön a kimenetre (írnia a terminálra) akkor csináld ezt,
      ha adat jön a hiba-csatornára akkor meg csináld azt.
      </p>

      <p class="info">
        A kilépési kód (<code>code</code>) általában 0 siker esetén, és nem 0 hiba esetén.
  Ez egy klasszikus "Unix" konvenció, ami azért a Windows világában is elég elterjedt.
  Így (ha a program írója követte ezt) könnyen meg tudod állapítani, hogy sikerült-e az amit akartál,
  vagy a processz amit elindítottál volna feldobta a talpát és hibával leállt.
      </p>
    </section>

    <section>
      <h2>7. Konfiguráció és környezet</h2>
      <p>
        Automatizáló scripteknél gyorsan kísértés, hogy "csak most egyszer" beleírod a fájlnevet, könyvtárat, URL-t,
        vagy valami token-szerű értéket. Ez rövid távon kényelmes, hosszú távon viszont csunyán visszaüt.
      </p>
      <p>
      Az integrációs scripteket pont azért írod mert automatizálni akarsz valamit. Általában nem egyszer,
      hanem sokszor. Lehet, hogy holnap már kicsi másképp. Egy másik fájlon. Más kezdeti feltétellel. 
      Más kimenettel. Stb. 
      </p>

      <p>
        A helyes minta általában a következő: 
      </p>
      <ul>
        <li>alapértelmezett érték a kódban (hogy könnyű legyen elindítani)</li>
        <li>amit felülírhatsz parancssori argumentumból (<code>process.argv</code>)</li>
        <li>vagy környezeti változóból (<code>process.env</code>) vett értékkel</li>
      </ul>

      <textarea data-lang="js" data-readonly>
// fájl: config.mjs
let baseDir = process.env.BASE_DIR || "exports"
let mode = process.env.MODE || "dev"

console.log("BASE_DIR:", baseDir)
console.log("MODE:", mode)
      </textarea>
    </section>

    <section>
      <h2>8. package.json - projektleíró és konfigurációs fájl</h2>

      <p>
        Amikor egy Node.js program már nem csak egyetlen fájlból áll, esetleg külső csomagokat is használ,
        akkor szükség van egy központi leíró fájlra. Ez a <code>package.json</code>.
      </p>

      <p>
        A <code>package.json</code> nem fut le, nem tartalmaz üzleti logikát, hanem azt tárolja, 
        hogy <strong>mi ez a projekt</strong>, <strong>hogyan kell értelmezni</strong>, és <strong>milyen függőségei vannak</strong>.
      </p>

      <h3>Mire jór a package.json?</h3>
      <ul>
        <li>a projekt azonosítására (név, verzió)</li>
        <li>a belépési pont (entry point) megadására</li>
        <li>a modulrendszer beállítására (ES module vs CommonJS)</li>
        <li>külső csomagok (libraryk) deklarálására</li>
        <li>egyszerű parancsok (script-ek) definiálására</li>
      </ul>

      <p>Például egy pici, modern Node projekt <code>package.json</code>-ja így nézhet ki:</p>

      <textarea data-lang="js" data-readonly>
    // fájl: package.json
    {
      "name": "node-automation-demo",
      "version": "1.0.0",
      "type": "module",
      "description": "Egyszerű Node.js automatizálási minta program",
      "private": true
    }
      </textarea>

      <p>A fenti példában a 
          <code>"type": "module"</code> sor mondja meg a Node-nak, hogy
          projekt szinten <strong>ES module szintaxist</strong> (<code>import</code>/<code>export</code>) használunk.
        E nélkül a Node alapértelmezésben a régi CommonJS modellt feltételezi,
        és az <code>import</code> kulcsszóra hibát dobna (persze, ha nem .js kiterjesztést
        adsz neki, hanem .mjs-t akkor továbbra is működik, ahogy eddig).
      </p>

      <h3>Függőségek röviden</h3>
      <p>
        Ha nem elég a beépített képesség és külső csomagot szeretnél használni
        (például CSV feldolgozáshoz, HTTP klienshez, Excel fájlokhoz),
        akkor azok a <code>dependencies</code> részbe kerülnek:
      </p>

      <textarea data-lang="js" data-readonly>
    // részlet egy package.json-ból
    {
      "dependencies": {
        "csv-parse": "^5.5.0"
      }
    }
      </textarea>

      <p>
      Így a node (és mindenki más aki olvassa a programodat) rögtön látja, hogy a progamod önállóan
      nem fog futni, hanem kellenek hozzá ezek a csomagok. Így gyorsan fel tudja telepíteni,
      méghozzá a megfelelő verziót, amivel kompatibilis a programod.
      A konkrét csomagkezeléssel (<code>npm install</code>, lock file-ok) majd később foglalkozunk.
      Egyelőre elég annyit megjegyezeni, hogy a 
        <strong>a <code>package.json</code> a Node projekt "névjegye és konfigurációs központja".</strong>
      </p>

      <p>
        A Node használata során gyakran <strong>projektekben gondolkodunk</strong>,
        és ebben a gondolkodásban a <code>package.json</code> a legfontosabb strukturáló elem.
      </p>
    </section>
    <section>
      <h2>9. Mérnöki felhasználási lehetőségek</h2>
      <p>
      Mire tudod használni a Node-ot? Nagyon sokmindenre. Gyakorlatilag bármire, 
      mivel ez egy általános célú nyelv. De azért álljon itt néhány példa:
      </p>
      <ul>
        <li><strong>Fájlfeldolgozás</strong>: CSV/JSON exportok tisztítása, normalizálása, átalakítása</li>
        <li><strong>Tömeges műveletek</strong>: fájlok átnevezése, mappastruktúrák rendezése</li>
        <li><strong>Orchestration</strong>: külső eszközök összefűzése (futtatás → ellenőrzés → feldolgozás → másik rendszer futás)</li>
        <li><strong>Riport előkészítés</strong>: adatösszesítés, köztes állományok generálása</li>
      </ul>

      <p>
        A JavaScript ebben a környezetben egy könnyen írható, jól olvasható, gyors iterációjú
        automatizálási nyelv, ami sokféle rendszer között tud kapcsolatot teremteni.
      </p>
    </section>
    <section>
      <a href="https://nodejs.org/docs/latest/api/" target="_blank" rel="noreferrer">Node Documentation</a>
    </section>
  </main>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/codemirror.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/mode/javascript/javascript.min.js"></script>
<script src="codeblocks.js"></script>
</html>
